-- ===================================================================
-- test top level window functions that are pushdownable
-- ===================================================================
-- a very simple window function with an aggregate and a window function
-- distribution column is on the partition by clause
SELECT
	user_id, COUNT(*) OVER (PARTITION BY user_id),
	rank() OVER (PARTITION BY user_id)
FROM
	users_table
ORDER BY
	1 DESC, 2 DESC, 3 DESC
LIMIT 5;
 user_id | count | rank 
---------+-------+------
       6 |    10 |    1
       6 |    10 |    1
       6 |    10 |    1
       6 |    10 |    1
       6 |    10 |    1
(5 rows)

-- a more complicated window clause, including an aggregate
-- in both the window clause and the target entry
SELECT
	user_id, avg(avg(value_3)) OVER (PARTITION BY user_id, MIN(value_2))
FROM
	users_table
GROUP BY
	1
ORDER BY
	2 DESC NULLS LAST, 1 DESC;
 user_id |       avg        
---------+------------------
       2 |                3
       4 | 2.82608695652174
       3 | 2.70588235294118
       6 |              2.6
       1 | 2.57142857142857
       5 | 2.46153846153846
(6 rows)

-- window clause operates on the results of a subquery
SELECT
	user_id, max(value_1) OVER (PARTITION BY user_id, MIN(value_2))
FROM (
	SELECT
		DISTINCT us.user_id, us.value_2, value_1, random() as r1
	FROM
		users_table as us, events_table
	WHERE 
		us.user_id = events_table.user_id AND event_type IN (1,2)
	ORDER BY 
		user_id, value_2
	) s
GROUP BY
	1, value_1
ORDER BY
	2 DESC, 1;
 user_id | max 
---------+-----
       1 |   5
       3 |   5
       3 |   5
       4 |   5
       5 |   5
       5 |   5
       6 |   5
       6 |   5
       1 |   4
       2 |   4
       3 |   4
       3 |   4
       3 |   4
       4 |   4
       4 |   4
       5 |   4
       5 |   4
       1 |   3
       2 |   3
       2 |   3
       2 |   3
       6 |   3
       2 |   2
       4 |   2
       4 |   2
       4 |   2
       6 |   2
       1 |   1
       3 |   1
       5 |   1
       6 |   1
       5 |   0
(32 rows)

-- window function operates on the results of 
-- a join
SELECT
	us.user_id,
	SUM(us.value_1) OVER (PARTITION BY us.user_id)
FROM
	users_table us
	JOIN
	events_table ev
	ON (us.user_id = ev.user_id)
GROUP BY
	1,
	value_1
ORDER BY
	1,
	2
LIMIT 5;
 user_id | sum 
---------+-----
       1 |  13
       1 |  13
       1 |  13
       1 |  13
       2 |  10
(5 rows)

-- the same query, but this time join with an alias
SELECT
	user_id, value_1, SUM(j.value_1) OVER (PARTITION BY j.user_id)
FROM
	(users_table_local us
	JOIN
  		events_table_local ev
	USING (user_id )
	) j 
GROUP BY
	user_id,
	value_1
ORDER BY
	3 DESC, 2 DESC, 1 DESC
LIMIT 5;
ERROR:  relation "users_table_local" does not exist
LINE 4:  (users_table_local us
          ^
-- querying views that have window functions should be ok
CREATE VIEW window_view AS
SELECT
  DISTINCT user_id, rank() OVER (PARTITION BY user_id ORDER BY value_1)
FROM
  users_table
GROUP BY
  user_id, value_1
HAVING count(*) > 1;
-- Window function in View works
SELECT *
FROM
	window_view
ORDER BY
	2 DESC, 1
LIMIT 10;
 user_id | rank 
---------+------
       5 |    6
       2 |    5
       4 |    5
       5 |    5
       2 |    4
       3 |    4
       4 |    4
       5 |    4
       6 |    4
       2 |    3
(10 rows)

-- the other way around also should work fine
-- query a view using window functions
CREATE VIEW users_view AS SELECT * FROM users_table;
SELECT
	DISTINCT user_id, rank() OVER (PARTITION BY user_id ORDER BY value_1)
FROM
	users_view
GROUP BY
	user_id, value_1
HAVING count(*) > 4;
 user_id | rank 
---------+------
       5 |    2
       5 |    1
       4 |    1
       2 |    1
       3 |    1
       4 |    2
(6 rows)

DROP VIEW users_view, window_view;
-- window function uses columns from two different tables
SELECT 
	DISTINCT ON (events_table.user_id, rnk) events_table.user_id, rank() OVER my_win AS rnk
FROM 
	events_table, users_table
WHERE 
	users_table.user_id = events_table.user_id
WINDOW
	my_win AS (PARTITION BY events_table.user_id, users_table.value_1 ORDER BY events_table.time DESC)
ORDER BY 
	rnk DESC, 1 DESC
LIMIT 10;
 user_id | rnk 
---------+-----
       3 | 121
       5 | 118
       2 | 116
       3 | 115
       4 | 113
       2 | 111
       5 | 109
       3 | 109
       4 | 106
       2 | 106
(10 rows)

-- the same query with reference tables on the partition by doesn't work
SELECT 
	DISTINCT ON (events_table.user_id, rnk) events_table.user_id, rank() OVER my_win AS rnk
FROM 
	events_table_ref as events_table, users_table
WHERE 
  users_table.user_id = events_table.user_id
WINDOW
	my_win AS (PARTITION BY events_table.user_id, users_table.value_1 ORDER BY events_table.time DESC)
ORDER BY
	rnk DESC, 1 DESC
LIMIT 10;
ERROR:  relation "events_table_ref" does not exist
LINE 4:  events_table_ref as events_table, users_table
         ^
-- ORDER BY in the window function is an aggragate
SELECT
	user_id, rank() OVER my_win as rnk, avg(value_2) as avg_val_2
FROM
	events_table
GROUP BY
	user_id, date_trunc('day', time)
WINDOW
	my_win AS (PARTITION BY user_id ORDER BY avg(event_type) DESC)
ORDER BY
	3 DESC, 2 DESC, 1 DESC;
 user_id | rnk |     avg_val_2      
---------+-----+--------------------
       1 |   1 | 3.3750000000000000
       3 |   2 | 3.1666666666666667
       5 |   2 | 2.6666666666666667
       6 |   2 | 2.5000000000000000
       4 |   2 | 2.5000000000000000
       2 |   1 | 2.4736842105263158
       4 |   1 | 2.4000000000000000
       1 |   2 | 2.1428571428571429
       5 |   1 | 2.0909090909090909
       2 |   2 | 2.0000000000000000
       6 |   1 | 2.0000000000000000
       3 |   1 | 1.8000000000000000
(12 rows)

-- lets push the limits of writing complex expressions aling with the window functions
SELECT
	COUNT(*) OVER (PARTITION BY user_id, user_id + 1),
	rank() OVER (PARTITION BY user_id) as cnt1,
	COUNT(*) OVER (PARTITION BY user_id, abs(value_1 - value_2)) as cnt2, 
	date_trunc('min', lag(time) OVER (PARTITION BY user_id)) as datee,
	rank() OVER my_win  as rnnk,
	avg(CASE
			WHEN user_id > 4
				THEN value_1
			ELSE value_2
         END) FILTER (WHERE user_id > 2) OVER my_win_2 as filtered_count,
	sum(user_id * (5.0 / (value_1 + value_2 + 0.1)) * value_3) FILTER (WHERE value_1::text LIKE '%1%') OVER my_win_4 as cnt_with_filter_2
FROM
	users_table
WINDOW
	my_win AS (PARTITION BY user_id, (value_1%3)::int ORDER BY time DESC),
	my_win_2 AS (PARTITION BY user_id, (value_1)::int ORDER BY time DESC),
	my_win_3 AS (PARTITION BY user_id,  date_trunc('min', time)),
	my_win_4 AS (my_win_3 ORDER BY value_2, value_3)
ORDER BY
  cnt_with_filter_2 DESC NULLS LAST, filtered_count DESC NULLS LAST, datee DESC NULLS LAST, rnnk DESC, cnt2 DESC, cnt1 DESC, user_id DESC
LIMIT 5;
 count | cnt1 | cnt2 |          datee           | rnnk |     filtered_count     | cnt_with_filter_2 
-------+------+------+--------------------------+------+------------------------+-------------------
    23 |    1 |    7 | Thu Nov 23 02:14:00 2017 |    6 | 0.00000000000000000000 |  72.7272727272727
    10 |    1 |    3 | Wed Nov 22 23:01:00 2017 |    1 | 1.00000000000000000000 |  57.1428571428571
    17 |    1 |    5 | Wed Nov 22 23:24:00 2017 |    8 |     3.0000000000000000 |  28.5714285714286
    17 |    1 |    5 |                          |   10 |     2.6666666666666667 |  28.5714285714286
    17 |    1 |    5 | Thu Nov 23 00:15:00 2017 |    7 |     3.6666666666666667 |  24.1935483870968
(5 rows)

-- some tests with GROUP BY along with PARTITION BY
SELECT
	user_id, 
	rank() OVER my_win as my_rank,
	avg(avg(event_type)) OVER my_win_2 as avg,
	max(time) as mx_time
FROM
	events_table
GROUP BY
	user_id,
	value_2
WINDOW
	my_win AS (PARTITION BY user_id, max(event_type) ORDER BY count(*) DESC),
	my_win_2 AS (PARTITION BY user_id, avg(user_id) ORDER BY count(*) DESC)
ORDER BY
	avg DESC,
	mx_time DESC,
	my_rank DESC,
	user_id DESC;
 user_id | my_rank |          avg           |             mx_time             
---------+---------+------------------------+---------------------------------
       1 |       4 |     4.0000000000000000 | Wed Nov 22 21:06:57.457147 2017
       3 |       1 |     3.4000000000000000 | Thu Nov 23 16:31:56.219594 2017
       4 |       2 |     3.3333333333333334 | Thu Nov 23 14:19:25.765876 2017
       4 |       1 |     3.3333333333333334 | Thu Nov 23 08:36:53.871919 2017
       1 |       1 |     3.2500000000000000 | Thu Nov 23 21:54:46.924477 2017
       6 |       1 |     3.0000000000000000 | Thu Nov 23 14:00:13.20013 2017
       6 |       2 |     3.0000000000000000 | Thu Nov 23 11:16:13.106691 2017
       6 |       1 |     3.0000000000000000 | Thu Nov 23 07:27:32.822068 2017
       2 |       2 |     2.8333333333333333 | Thu Nov 23 13:27:37.441959 2017
       5 |       2 |     2.7500000000000000 | Thu Nov 23 14:28:51.833214 2017
       5 |       2 |     2.7500000000000000 | Thu Nov 23 14:23:09.889786 2017
       2 |       1 |     2.7142857142857143 | Thu Nov 23 15:58:49.273421 2017
       1 |       2 |     2.6666666666666667 | Thu Nov 23 09:23:30.994345 2017
       3 |       1 |     2.5714285714285714 | Thu Nov 23 16:44:41.903713 2017
       1 |       1 |     2.4000000000000000 | Thu Nov 23 10:23:27.617726 2017
       3 |       1 |     2.3333333333333333 | Thu Nov 23 01:17:49.040685 2017
       4 |       1 |     2.2000000000000000 | Thu Nov 23 18:10:21.338399 2017
       3 |       1 |     2.0000000000000000 | Thu Nov 23 18:08:26.550729 2017
       2 |       1 |     2.0000000000000000 | Thu Nov 23 17:26:14.563216 2017
       4 |       1 | 2.00000000000000000000 | Thu Nov 23 16:20:33.264457 2017
       5 |       1 |     2.0000000000000000 | Thu Nov 23 16:11:02.929469 2017
       5 |       1 |     2.0000000000000000 | Thu Nov 23 14:40:40.467511 2017
       2 |       1 |     2.0000000000000000 | Thu Nov 23 14:02:47.738901 2017
       5 |       1 |     2.0000000000000000 | Thu Nov 23 13:26:45.571108 2017
       1 |       3 |     2.0000000000000000 | Thu Nov 23 11:09:38.074595 2017
       3 |       1 |     2.0000000000000000 | Thu Nov 23 09:38:45.338008 2017
       4 |       3 | 2.00000000000000000000 | Thu Nov 23 08:14:18.231273 2017
       4 |       3 | 2.00000000000000000000 | Thu Nov 23 07:32:45.521278 2017
       3 |       2 |     2.0000000000000000 | Thu Nov 23 06:44:50.887182 2017
       2 |       2 |     2.0000000000000000 | Thu Nov 23 04:05:16.217731 2017
       2 |       1 | 1.00000000000000000000 | Thu Nov 23 03:35:04.321504 2017
(31 rows)

-- test for range and rows mode and different window functions
-- mostly to make sure that deparsing works fine
SELECT
	user_id,
	rank() OVER (PARTITION BY user_id ROWS BETWEEN
				 UNBOUNDED PRECEDING AND CURRENT ROW),
	dense_rank() OVER (PARTITION BY user_id RANGE BETWEEN
					   UNBOUNDED PRECEDING AND CURRENT ROW),
	CUME_DIST() OVER (PARTITION BY user_id RANGE BETWEEN
					  UNBOUNDED PRECEDING AND  UNBOUNDED FOLLOWING),
	PERCENT_RANK() OVER (PARTITION BY user_id ORDER BY avg(value_1) RANGE BETWEEN
						 UNBOUNDED PRECEDING AND  UNBOUNDED FOLLOWING)
FROM
	users_table
GROUP BY
	1
ORDER BY
	4 DESC,3 DESC,2 DESC ,1 DESC;
 user_id | rank | dense_rank | cume_dist | percent_rank 
---------+------+------------+-----------+--------------
       6 |    1 |          1 |         1 |            0
       5 |    1 |          1 |         1 |            0
       4 |    1 |          1 |         1 |            0
       3 |    1 |          1 |         1 |            0
       2 |    1 |          1 |         1 |            0
       1 |    1 |          1 |         1 |            0
(6 rows)

-- some tests with GROUP BY, HAVING and LIMIT
SELECT 
	user_id, sum(event_type) OVER my_win , event_type
FROM
	events_table
GROUP BY
	user_id, event_type
HAVING count(*) > 2 
	WINDOW my_win AS (PARTITION BY user_id, max(event_type) ORDER BY count(*) DESC)
ORDER BY 
	2 DESC, 3 DESC, 1 DESC
LIMIT 
	5;
 user_id | sum | event_type 
---------+-----+------------
       4 |   4 |          4
       3 |   4 |          4
       2 |   4 |          4
       1 |   4 |          4
       5 |   3 |          3
(5 rows)

-- Group by has more columns than partition by
-- !!!!!!!!!!!!!!!!WRONG RESULTS
SELECT
	DISTINCT user_id, SUM(value_2) OVER (PARTITION BY user_id)
FROM
	users_table
GROUP BY
	user_id, value_1, value_2
HAVING count(*) > 2
ORDER BY
	2 DESC, 1
LIMIT
	10;
 user_id | sum 
---------+-----
       5 |   3
       5 |   3
       4 |   2
       4 |   2
(4 rows)

SELECT
	DISTINCT ON (user_id) user_id, SUM(value_2) OVER (PARTITION BY user_id)
FROM
	users_table
GROUP BY
	user_id, value_1, value_2
HAVING count(*) > 2
ORDER BY
	1, 2 DESC
LIMIT
	10;
 user_id | sum 
---------+-----
       4 |   2
       5 |   3
(2 rows)

SELECT
	DISTINCT ON (SUM(value_1) OVER (PARTITION BY user_id)) user_id, SUM(value_2) OVER (PARTITION BY user_id)
FROM
	users_table
GROUP BY
	user_id, value_1, value_2
HAVING count(*) > 2
ORDER BY
	(SUM(value_1) OVER (PARTITION BY user_id)) , 2 DESC, 1
LIMIT
	10;
 user_id | sum 
---------+-----
       5 |   3
       4 |   2
(2 rows)

 
-- not a meaningful query, with interesting syntax
SELECT
	user_id, 
	AVG(avg(value_1)) OVER (PARTITION BY user_id, max(user_id), MIN(value_2)), 
	AVG(avg(user_id)) OVER (PARTITION BY user_id, min(user_id), AVG(value_1))
FROM
	users_table
GROUP BY
	1
ORDER BY
	3 DESC, 2 DESC, 1 DESC;
 user_id |        avg         |          avg           
---------+--------------------+------------------------
       6 | 2.1000000000000000 |     6.0000000000000000
       5 | 2.6538461538461538 |     5.0000000000000000
       4 | 2.7391304347826087 |     4.0000000000000000
       3 | 2.3529411764705882 |     3.0000000000000000
       2 | 2.3333333333333333 |     2.0000000000000000
       1 | 3.2857142857142857 | 1.00000000000000000000
(6 rows)

